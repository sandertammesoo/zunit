######################################################################
# This file was autogenerated by 'configure'. Do not edit it directly!
# Invocation was: ./configure --prefix=~/.local
######################################################################
PREFIX=~/.local
######################################################################
# vim: ft=make sw=4 ts=4 noet!

# Default installation directory (if not overridden)
PREFIX ?= /usr/local

# The default shell to use (if not overridden)
SHELL  ?= zsh

# Options for the cram testing framework
CRAM_OPTS ?= -v

# Define project structure (directories)
PROJECT ?= $(CURDIR)
BIN     ?= ${PROJECT}/bin
OUT     ?= ${PROJECT}/out
DOCS    ?= ${PROJECT}/docs
SRC     ?= ${PROJECT}/src
TESTS   ?= ${PROJECT}/tests

# Zsh-related settings
ZSH_VERSION     ?= zsh-5.8
CONTAINER_ROOT  ?= /zunit
USE_CONTAINER   ?= docker
CONTAINER_IMAGE ?= desyncr/zsh-docker-

# Define executable and source variables
PROG ?= ${OUT}/zunit
EXEC ?= ${BIN}/zunit
SRC  ?= ${SRC}
GLOB ?=

# Gather all source files except `zunit.zsh`
LIB      = $(filter-out ${SRC}/zunit.zsh,$(wildcard ${SRC}/*.zsh))
COMMANDS = $(sort $(wildcard ${SRC}/commands/*.zsh))
REPORTS  = $(sort $(wildcard ${SRC}/reports/*.zsh))

# Combine all files into a single list
GLOB    += ${LIB} ${REPORTS} ${COMMANDS} ${SRC}/zunit.zsh

# Define version information
VERSION_FILE = ${PROJECT}/VERSION
VERSION ?= $(shell cat ${VERSION_FILE} 2>/dev/null || echo "develop")

# Create an autogenerated file banner
BANNER_SEP  = $(shell printf '%*s' 70 | tr ' ' '\#')
BANNER_TEXT = This file was autogenerated by \`make\`. Do not edit it directly!
BANNER      = ${BANNER_SEP}\n\# ${BANNER_TEXT}\n${BANNER_SEP}\n

# Add a file header for generated scripts
HEADER_TEXT =\
\#!/usr/bin/env zsh\n\
\# Zunit: A unit test framework for zsh\n\
\# License: MIT License\n

# Helper function: Perform in-place sed replacement
define ised
	sed $(1) $(2) > "$(2).1"
	mv "$(2).1" "$(2)"
endef

# Helper function: Perform in-place sed replacement with extended regex
define isede
	sed -E $(1) $(2) > "$(2).1"
	mv "$(2).1" "$(2)"
endef

# Define main build targets (these are not actual files)
.PHONY: all build clean install itests tests uninstall release publish deploy check-version full-release setup-gpg cleanup-release cleanup-release-force bump-version bump-patch bump-minor bump-major

# Default target: Run 'build' when 'make' is executed
all: build

######################################################################
# RELEASE WORKFLOW
# 
# 1. (Optional) Run: make setup-gpg    # Configure GPG for signing
# 2. Bump version number:              # Automated version management
#    - make bump-patch                 # x.y.z → x.y.z+1 (bug fixes)
#    - make bump-minor                 # x.y.z → x.y+1.0 (new features)
#    - make bump-major                 # x.y.z → x+1.0.0 (breaking changes)
#    OR manually update VERSION file  
# 3. Run: make check-version           # Check status (GPG, git auth, etc.)
# 4. Run: make full-release            # Complete workflow
#    OR run individual steps:
#    - make release                    # Build, commit, and push to develop
#    - make publish                    # Create git tag, merge to master, push both
#    - make deploy                     # Create release archives
#
# What gets pushed where:
# - make release: Pushes code changes to origin/develop
# - make publish: Merges to master, pushes master + git tag to origin
# - Both require authentication (SSH recommended)
#
# If release fails: make cleanup-release  # Clean up and retry
# Note: GPG signing is optional - releases work without it
######################################################################

# Prepare a release: build, test, and commit the built executable
release: build test
	@echo "Preparing release ${VERSION}..."
	@if [ -z "${VERSION}" ] || [ "${VERSION}" = "develop" ]; then \
		echo "Error: VERSION must be set to a valid version number"; \
		echo "Current VERSION: ${VERSION}"; \
		echo "Please update the VERSION file first"; \
		exit 1; \
	fi
	@# Check for uncommitted changes, but allow rebuilt executable
	@if git status --porcelain | grep -v " M bin/zunit$$" | grep -q .; then \
		echo "Error: Working directory has uncommitted changes other than the built executable."; \
		echo "Please commit or stash these changes first:"; \
		git status --porcelain | grep -v " M bin/zunit$$"; \
		exit 1; \
	fi
	@echo "Building and testing version ${VERSION}..."
	@echo "Adding built executable to git..."
	git add ${EXEC}
	git commit -S -m "Build release ${VERSION}" || echo "No changes to commit"
	@echo "Pushing changes to develop branch..."
	@if git status --porcelain -b | head -1 | grep -q "ahead"; then \
		echo "Local commits found, pushing to origin..."; \
		if ! git push origin develop 2>/dev/null; then \
			echo ""; \
			echo "❌ Failed to push to develop branch. This is likely an authentication issue:"; \
			echo ""; \
			echo "For HTTPS remotes:"; \
			echo "  1. Create a Personal Access Token at: https://github.com/settings/tokens"; \
			echo "  2. Use token as password when prompted"; \
			echo "  3. Or configure credential helper: git config --global credential.helper store"; \
			echo ""; \
			echo "For SSH remotes (recommended):"; \
			echo "  1. Switch to SSH: git remote set-url origin git@github.com:sandertammesoo/zunit.git"; \
			echo "  2. Set up SSH key: https://docs.github.com/en/authentication/connecting-to-github-with-ssh"; \
			echo ""; \
			echo "To retry after fixing auth: make release"; \
			exit 1; \
		fi; \
	else \
		echo "No local commits to push"; \
	fi
	@echo "✅ Release ${VERSION} prepared and pushed to develop branch"
	@echo "Next steps:"
	@echo "  make publish  # Create git tag, merge to master, and push both"
	@echo "  make deploy   # Create release archives"
	@echo ""
	@echo "📋 Quick link to create GitHub release:"
	@echo "   https://github.com/sandertammesoo/zunit/releases/new?tag=v${VERSION}"

# Create and push a git tag for the release
publish:
	@echo "Publishing release ${VERSION}..."
	@if [ -z "${VERSION}" ] || [ "${VERSION}" = "develop" ]; then \
		echo "Error: VERSION must be set to a valid version number"; \
		exit 1; \
	fi
	@if git tag -l | grep -q "^v${VERSION}$$"; then \
		echo "Error: Tag v${VERSION} already exists"; \
		echo "To remove it and retry: git tag -d v${VERSION}"; \
		exit 1; \
	fi
	@echo "Checking git authentication..."
	@if git remote get-url origin | grep -q "^https://"; then \
		echo "⚠️  Using HTTPS remote. Authentication options:"; \
		echo ""; \
		echo "For HTTPS remotes:"; \
		echo "  1. Create a Personal Access Token at: https://github.com/settings/tokens"; \
		echo "  2. Use token as password when prompted"; \
		echo "  3. Or configure credential helper: git config --global credential.helper store"; \
		echo ""; \
		echo "For SSH remotes (recommended):"; \
		echo "  1. Switch to SSH: git remote set-url origin git@github.com:sandertammesoo/zunit.git"; \
		echo "  2. Set up SSH key: https://docs.github.com/en/authentication/connecting-to-github-with-ssh"; \
		echo ""; \
	fi
	@echo "Creating git tag v${VERSION}..."
	@if command -v gpg >/dev/null 2>&1 && gpg --list-secret-keys >/dev/null 2>&1 && [ -n "$$(gpg --list-secret-keys --keyid-format LONG 2>/dev/null)" ]; then \
		echo "✅ GPG configured, creating signed tag..."; \
		git tag -s "v${VERSION}" -m "Release ${VERSION}"; \
	else \
		echo "⚠️  GPG not configured, creating unsigned tag..."; \
		echo "   (To enable signed tags, configure GPG as shown in 'make setup-gpg')"; \
		git tag -a "v${VERSION}" -m "Release ${VERSION}"; \
	fi
	@echo "Pushing tag to origin..."
	@if ! git push origin "v${VERSION}" 2>/dev/null; then \
		echo ""; \
		echo "❌ Failed to push tag. This is likely an authentication issue:"; \
		echo ""; \
		echo "For HTTPS remotes:"; \
		echo "  1. Create a Personal Access Token at: https://github.com/settings/tokens"; \
		echo "  2. Use token as password when prompted"; \
		echo "  3. Or configure credential helper: git config --global credential.helper store"; \
		echo ""; \
		echo "For SSH remotes (recommended):"; \
		echo "  1. Switch to SSH: git remote set-url origin git@github.com:sandertammesoo/zunit.git"; \
		echo "  2. Set up SSH key: https://docs.github.com/en/authentication/connecting-to-github-with-ssh"; \
		echo ""; \
		echo "To retry after fixing auth: make publish"; \
		exit 1; \
	fi
	@echo "Merging to master branch..."
	@git checkout master && \
	git merge --no-ff develop -m "Release ${VERSION}" && \
	echo "Pushing master branch..." && \
	if ! git push origin master 2>/dev/null; then \
		echo ""; \
		echo "❌ Failed to push master branch. This is likely an authentication issue:"; \
		echo ""; \
		echo "For HTTPS remotes:"; \
		echo "  1. Create a Personal Access Token at: https://github.com/settings/tokens"; \
		echo "  2. Use token as password when prompted"; \
		echo "  3. Or configure credential helper: git config --global credential.helper store"; \
		echo ""; \
		echo "For SSH remotes (recommended):"; \
		echo "  1. Switch to SSH: git remote set-url origin git@github.com:sandertammesoo/zunit.git"; \
		echo "  2. Set up SSH key: https://docs.github.com/en/authentication/connecting-to-github-with-ssh"; \
		echo ""; \
		echo "To retry after fixing auth: git checkout develop && make publish"; \
		git checkout develop; \
		exit 1; \
	fi && \
	git checkout develop
	@echo ""
	@echo "✅ Release v${VERSION} published successfully!"
	@echo "   📦 Tag created and pushed"
	@echo "   🔀 Merged to master and pushed" 
	@echo ""
	@echo "🎉 Next steps:"
	@echo "  make deploy   # Create release archives"
	@echo ""
	@echo "🚀 Create GitHub Release:"
	@echo "   https://github.com/sandertammesoo/zunit/releases/new?tag=v${VERSION}"

# Create release archives and signatures
deploy:
	@echo "Creating deployment artifacts for ${VERSION}..."
	@if [ -z "${VERSION}" ] || [ "${VERSION}" = "develop" ]; then \
		echo "Error: VERSION must be set to a valid version number"; \
		exit 1; \
	fi
	@if ! git tag -l | grep -q "^v${VERSION}$$"; then \
		echo "Error: Tag v${VERSION} does not exist. Run 'make publish' first."; \
		exit 1; \
	fi
	@echo "Creating archive from tag v${VERSION}..."
	git archive --format=tar.gz --output="zunit-${VERSION}.tar.gz" --prefix="zunit-${VERSION}/" "v${VERSION}"
	@echo "Checking GPG configuration..."
	@if command -v gpg >/dev/null 2>&1; then \
		if gpg --list-secret-keys >/dev/null 2>&1 && [ -n "$$(gpg --list-secret-keys --keyid-format LONG 2>/dev/null)" ]; then \
			echo "✅ GPG is configured, creating signature..."; \
			gpg --armor --detach-sign "zunit-${VERSION}.tar.gz" && \
			echo "✅ Signature created: zunit-${VERSION}.tar.gz.asc" && \
			echo "Verifying signature..." && \
			gpg --verify "zunit-${VERSION}.tar.gz.asc" "zunit-${VERSION}.tar.gz" && \
			echo "✅ Signature verified successfully"; \
		else \
			echo "⚠️  GPG is installed but not configured with a secret key"; \
			echo "   To set up GPG signing:"; \
			echo "   1. Generate a key: gpg --full-generate-key"; \
			echo "   2. List keys: gpg --list-secret-keys --keyid-format LONG"; \
			echo "   3. Configure git: git config user.signingkey <KEY_ID>"; \
			echo "   Skipping signature creation for now..."; \
		fi; \
	else \
		echo "⚠️  GPG not found. To enable signing:"; \
		echo "   macOS: brew install gnupg"; \
		echo "   Ubuntu/Debian: sudo apt install gnupg"; \
		echo "   Then configure with: gpg --full-generate-key"; \
		echo "   Skipping signature creation for now..."; \
	fi
	@echo ""
	@echo "✅ Deployment artifacts created:"
	@echo "  📦 zunit-${VERSION}.tar.gz"
	@if [ -f "zunit-${VERSION}.tar.gz.asc" ]; then \
		echo "  🔐 zunit-${VERSION}.tar.gz.asc"; \
	else \
		echo "  ⚠️  No signature file (GPG not configured)"; \
	fi
	@echo ""
	@echo "🎉 Release ${VERSION} is now complete!"
	@echo ""
	@echo "📋 Create GitHub Release with these artifacts:"
	@echo "   https://github.com/sandertammesoo/zunit/releases/new?tag=v${VERSION}"

# Check version and git status before release
check-version:
	@echo "Current version: ${VERSION}"
	@echo "Git branch: $$(git branch --show-current)"
	@echo "Git status:"
	@git status --short
	@echo ""
	@echo "Unpushed commits:"
	@git log --oneline origin/develop..HEAD 2>/dev/null || echo "  (Unable to check - may need to fetch origin first)"
	@echo ""
	@if [ -z "${VERSION}" ] || [ "${VERSION}" = "develop" ]; then \
		echo "⚠️  VERSION is not set to a release version"; \
		echo "   📝 Update the VERSION file or use version bump targets:"; \
		echo "      make bump-patch  # Increment patch (x.y.z → x.y.z+1)"; \
		echo "      make bump-minor  # Increment minor (x.y.z → x.y+1.0)"; \
		echo "      make bump-major  # Increment major (x.y.z → x+1.0.0)"; \
	else \
		echo "✅ VERSION is set to: ${VERSION}"; \
	fi
	@if [ -n "$$(git status --porcelain)" ]; then \
		echo "⚠️  Working directory has uncommitted changes"; \
	else \
		echo "✅ Working directory is clean"; \
	fi
	@local_tag_exists=$$(git tag -l | grep -q "^v${VERSION}$$" && echo "true" || echo "false"); \
	remote_tag_exists=$$(git ls-remote --tags origin 2>/dev/null | grep -q "refs/tags/v${VERSION}$$" && echo "true" || echo "false"); \
	if [ "$$local_tag_exists" = "true" ] && [ "$$remote_tag_exists" = "true" ]; then \
		echo "⚠️  Tag v${VERSION} exists locally and on remote"; \
		echo "   📝 Use version bump targets to create a new version:"; \
		echo "      make bump-patch  # New patch release (recommended)"; \
		echo "      make bump-minor  # New minor release"; \
		echo "      make bump-major  # New major release"; \
	elif [ "$$local_tag_exists" = "true" ] && [ "$$remote_tag_exists" = "false" ]; then \
		echo "⚠️  Tag v${VERSION} exists locally but not on remote"; \
		echo "   🧹 Clean up local tag: make cleanup-release"; \
		echo "   📝 Or bump version: make bump-patch"; \
	elif [ "$$local_tag_exists" = "false" ] && [ "$$remote_tag_exists" = "true" ]; then \
		echo "⚠️  Tag v${VERSION} exists on remote but not locally"; \
		echo "   📝 Use version bump targets to create a new version:"; \
		echo "      make bump-patch  # New patch release (recommended)"; \
		echo "      make bump-minor  # New minor release"; \
		echo "      make bump-major  # New major release"; \
	else \
		echo "✅ Tag v${VERSION} is available"; \
	fi
	@echo ""
	@echo "GPG Status:"
	@if command -v gpg >/dev/null 2>&1; then \
		if gpg --list-secret-keys >/dev/null 2>&1 && [ -n "$$(gpg --list-secret-keys --keyid-format LONG 2>/dev/null)" ]; then \
			echo "✅ GPG is installed and configured"; \
			echo "   📝 Signed tags and release signatures will be created"; \
		else \
			echo "⚠️  GPG is installed but not configured"; \
			echo "   📝 Unsigned tags will be created, no signatures"; \
		fi; \
	else \
		echo "⚠️  GPG not installed"; \
		echo "   📝 Unsigned tags will be created, no signatures"; \
	fi
	@echo ""
	@echo "Git Authentication:"
	@if git remote get-url origin | grep -q "^https://"; then \
		echo "⚠️  Using HTTPS remote - authentication setup needed"; \
		echo "   🔗 Remote: $$(git remote get-url origin)"; \
		echo ""; \
		echo "For HTTPS remotes:"; \
		echo "  1. Create a Personal Access Token at: https://github.com/settings/tokens"; \
		echo "  2. Use token as password when prompted"; \
		echo "  3. Or configure credential helper: git config --global credential.helper store"; \
		echo ""; \
		echo "For SSH remotes (recommended):"; \
		echo "  1. Switch to SSH: git remote set-url origin git@github.com:sandertammesoo/zunit.git"; \
		echo "  2. Set up SSH key: https://docs.github.com/en/authentication/connecting-to-github-with-ssh"; \
		echo ""; \
	elif git remote get-url origin | grep -q "^git@"; then \
		echo "✅ Using SSH remote"; \
		echo "   🔗 Remote: $$(git remote get-url origin)"; \
	else \
		echo "❓ Unknown remote type: $$(git remote get-url origin)"; \
		echo ""; \
		echo "For HTTPS remotes:"; \
		echo "  1. Create a Personal Access Token at: https://github.com/settings/tokens"; \
		echo "  2. Use token as password when prompted"; \
		echo "  3. Or configure credential helper: git config --global credential.helper store"; \
		echo ""; \
		echo "For SSH remotes (recommended):"; \
		echo "  1. Switch to SSH: git remote set-url origin git@github.com:sandertammesoo/zunit.git"; \
		echo "  2. Set up SSH key: https://docs.github.com/en/authentication/connecting-to-github-with-ssh"; \
		echo ""; \
	fi

# Complete release workflow: release -> publish -> deploy
full-release: check-version release publish deploy
	@echo ""
	@echo "🎉🎉🎉 Release ${VERSION} completed successfully! 🎉🎉🎉"
	@echo ""
	@echo "✅ What was accomplished:"
	@echo "  📦 Built and tested release ${VERSION}"
	@echo "  🔀 Merged develop → master"  
	@echo "  🏷️  Created and pushed git tag v${VERSION}"
	@echo "  📦 Generated release archive: zunit-${VERSION}.tar.gz"
	@if [ -f "zunit-${VERSION}.tar.gz.asc" ]; then \
		echo "  🔐 Generated GPG signature: zunit-${VERSION}.tar.gz.asc"; \
	fi
	@echo ""
	@echo "🚀 NEXT: Create GitHub Release"
	@echo "   📋 Click here: https://github.com/sandertammesoo/zunit/releases/new?tag=v${VERSION}"
	@echo ""
	@echo "📝 Additional steps:"
	@echo "  • Upload the .tar.gz and .asc files to the GitHub release"
	@echo "  • Update package managers (Homebrew, AUR, etc.)"
	@echo "  • Announce the release!"

# Setup GPG for signing releases (guidance only)
setup-gpg:
	@echo "🔐 GPG Setup Guide for Release Signing"
	@echo "======================================"
	@echo ""
	@if command -v gpg >/dev/null 2>&1; then \
		echo "✅ GPG is already installed"; \
	else \
		echo "📦 Install GPG first:"; \
		echo "   macOS:         brew install gnupg"; \
		echo "   Ubuntu/Debian: sudo apt install gnupg"; \
		echo "   CentOS/RHEL:   sudo yum install gnupg2"; \
		echo ""; \
	fi
	@if gpg --list-secret-keys >/dev/null 2>&1 && [ -n "$$(gpg --list-secret-keys --keyid-format LONG 2>/dev/null)" ]; then \
		echo "✅ GPG key already exists"; \
		echo ""; \
		echo "Current keys:"; \
		gpg --list-secret-keys --keyid-format LONG | grep -E "(sec|uid)"; \
	else \
		echo "🔑 Generate a GPG key:"; \
		echo "   gpg --full-generate-key"; \
		echo "   (Choose RSA, 4096 bits, no expiration)"; \
		echo ""; \
		echo "🔧 Configure Git to use your key:"; \
		echo "   gpg --list-secret-keys --keyid-format LONG"; \
		echo "   git config --global user.signingkey <KEY_ID>"; \
		echo "   git config --global commit.gpgsign true"; \
		echo "   git config --global tag.gpgsign true"; \
	fi
	@echo ""
	@echo "🧪 Test your setup:"
	@echo "   gpg --armor --detach-sign Makefile"
	@echo "   gpg --verify Makefile.asc Makefile"
	@echo "   rm Makefile.asc"
	@echo ""
	@echo "📚 More info: https://docs.github.com/en/authentication/managing-commit-signature-verification"

# Clean up failed release attempts (smart cleanup - preserves successful releases)
cleanup-release:
	@echo "🧹 Cleaning up failed release for ${VERSION}..."
	@if [ -z "${VERSION}" ] || [ "${VERSION}" = "develop" ]; then \
		echo "Error: VERSION must be set"; \
		exit 1; \
	fi
	@local_tag_exists=$$(git tag -l | grep -q "^v${VERSION}$$" && echo "true" || echo "false"); \
	remote_tag_exists=$$(git ls-remote --tags origin 2>/dev/null | grep -q "refs/tags/v${VERSION}$$" && echo "true" || echo "false"); \
	if [ "$$local_tag_exists" = "true" ] && [ "$$remote_tag_exists" = "true" ]; then \
		echo "✅ Tag v${VERSION} exists locally and remotely - this appears to be a successful release"; \
		echo "   📝 Local tag will NOT be removed (use cleanup-release-force if really needed)"; \
		echo "   🧹 Only cleaning up local artifacts..."; \
	elif [ "$$local_tag_exists" = "true" ] && [ "$$remote_tag_exists" = "false" ]; then \
		echo "🗑️  Local tag v${VERSION} exists but not on remote - removing failed release tag"; \
		git tag -d "v${VERSION}"; \
	elif [ "$$local_tag_exists" = "false" ] && [ "$$remote_tag_exists" = "true" ]; then \
		echo "✅ Remote tag v${VERSION} exists, no local tag to clean up"; \
	else \
		echo "✅ No tags found for v${VERSION}"; \
	fi
	@if [ -f "zunit-${VERSION}.tar.gz" ]; then \
		echo "Removing zunit-${VERSION}.tar.gz..."; \
		rm -f "zunit-${VERSION}.tar.gz"; \
	fi
	@if [ -f "zunit-${VERSION}.tar.gz.asc" ]; then \
		echo "Removing zunit-${VERSION}.tar.gz.asc..."; \
		rm -f "zunit-${VERSION}.tar.gz.asc"; \
	fi
	@echo "✅ Cleanup completed. You can now retry the release."

# Force cleanup including remote tags (USE WITH CAUTION!)
cleanup-release-force:
	@echo "🧹💥 FORCE cleaning up release for ${VERSION} (including remote tags)..."
	@if [ -z "${VERSION}" ] || [ "${VERSION}" = "develop" ]; then \
		echo "Error: VERSION must be set"; \
		exit 1; \
	fi
	@echo "⚠️  WARNING: This will remove tags from remote repository!"
	@echo "⚠️  This may affect other users who have already pulled the tag."
	@echo ""
	@read -p "Are you sure you want to continue? (type 'yes' to confirm): " confirm; \
	if [ "$$confirm" != "yes" ]; then \
		echo "❌ Cleanup cancelled"; \
		exit 1; \
	fi
	@if git tag -l | grep -q "^v${VERSION}$$"; then \
		echo "Removing local tag v${VERSION}..."; \
		git tag -d "v${VERSION}"; \
	fi
	@if git ls-remote --tags origin | grep -q "refs/tags/v${VERSION}$$"; then \
		echo "Removing remote tag v${VERSION}..."; \
		git push origin --delete "v${VERSION}"; \
	fi
	@if [ -f "zunit-${VERSION}.tar.gz" ]; then \
		echo "Removing zunit-${VERSION}.tar.gz..."; \
		rm -f "zunit-${VERSION}.tar.gz"; \
	fi
	@if [ -f "zunit-${VERSION}.tar.gz.asc" ]; then \
		echo "Removing zunit-${VERSION}.tar.gz.asc..."; \
		rm -f "zunit-${VERSION}.tar.gz.asc"; \
	fi
	@echo "✅ Force cleanup completed. You can now retry the release."

######################################################################
# VERSION MANAGEMENT
# 
# Automatically increment version numbers:
# - make bump-version    # Increment patch version (default)
# - make bump-patch      # Increment patch version (x.y.z -> x.y.z+1)
# - make bump-minor      # Increment minor version (x.y.z -> x.y+1.0)
# - make bump-major      # Increment major version (x.y.z -> x+1.0.0)
######################################################################

# Default version bump (patch)
bump-version: bump-patch

# Bump patch version (x.y.z -> x.y.z+1)
bump-patch:
	@echo "🔢 Bumping patch version..."
	@current_version=$$(cat VERSION); \
	if [[ "$$current_version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$$ ]]; then \
		major=$${BASH_REMATCH[1]}; \
		minor=$${BASH_REMATCH[2]}; \
		patch=$${BASH_REMATCH[3]}; \
		new_patch=$$((patch + 1)); \
		new_version="$$major.$$minor.$$new_patch"; \
		echo "$$new_version" > VERSION; \
		echo "✅ Version bumped: $$current_version → $$new_version"; \
		git add VERSION && git commit -m "Bump version to $$new_version"; \
	else \
		echo "❌ Error: VERSION file contains invalid format: $$current_version"; \
		echo "   Expected format: x.y.z (e.g., 1.2.3)"; \
		exit 1; \
	fi

# Bump minor version (x.y.z -> x.y+1.0)
bump-minor:
	@echo "🔢 Bumping minor version..."
	@current_version=$$(cat VERSION); \
	if [[ "$$current_version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$$ ]]; then \
		major=$${BASH_REMATCH[1]}; \
		minor=$${BASH_REMATCH[2]}; \
		new_minor=$$((minor + 1)); \
		new_version="$$major.$$new_minor.0"; \
		echo "$$new_version" > VERSION; \
		echo "✅ Version bumped: $$current_version → $$new_version"; \
		git add VERSION && git commit -m "Bump version to $$new_version"; \
	else \
		echo "❌ Error: VERSION file contains invalid format: $$current_version"; \
		echo "   Expected format: x.y.z (e.g., 1.2.3)"; \
		exit 1; \
	fi

# Bump major version (x.y.z -> x+1.0.0)
bump-major:
	@echo "🔢 Bumping major version..."
	@current_version=$$(cat VERSION); \
	if [[ "$$current_version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$$ ]]; then \
		major=$${BASH_REMATCH[1]}; \
		new_major=$$((major + 1)); \
		new_version="$$new_major.0.0"; \
		echo "$$new_version" > VERSION; \
		echo "✅ Version bumped: $$current_version → $$new_version"; \
		git add VERSION && git commit -m "Bump version to $$new_version"; \
	else \
		echo "❌ Error: VERSION file contains invalid format: $$current_version"; \
		echo "   Expected format: x.y.z (e.g., 1.2.3)"; \
		exit 1; \
	fi

# Run commands inside a container (if enabled) TODO: Determine how, when and why to use
.container:
ifeq (${USE_CONTAINER}, docker)
	@docker run --rm --privileged=true -it -v ${PROJECT}:/zunit ${CONTAINER_IMAGE}${ZSH_VERSION} $(shell echo "${COMMAND}" | sed "s|${PROJECT}|${CONTAINER_ROOT}|g")
else ifeq (${USE_CONTAINER}, no)
	${COMMAND}
endif

# Generate documentation TODO: Determine how, when and why to use
docs:
	mkdir ${DOCS}
	cd ${DOCS}
	zsh -dfilc "zsd -v --scomm --cignore '(\#*FUNCTION:[[:space:]][\:\∞\.\+\@\-a-zA-Z0-9]*[\[]*|}[[:space:]]\#[[:space:]][\]]*)' ${GLOB}"

# Gather project info TODO: Determine how, when and why to use
info:
	@${MAKE} .container COMMAND="sh -c 'cat ${PROJECT}/VERSION; zsh --version; git --version; env'"

# Run tests TODO: Determine how, when and why to use
tests:
	@${make} .container command="sh -c 'zdotdir=${tests} zunit=${project} cram ${cram_opts} --shell=zsh ${test}'"

# Run the main Zunit program
test: build
	${EXEC} run

# Install Zunit locally
install:
	install -cv -m755 ${EXEC} ${PREFIX}/bin/zunit

# Uninstall Zunit
uninstall:
	rm -f ${PREFIX}/bin/zunit

# Clean up generated files
clean:
	rm -rf ${BIN} ${OUT} Makefile

# Install required dependencies (cram testing framework) TODO: Determine how, when and why to use
install-deps:
	sudo pip install cram=='0.6.*'

# Build the Zunit binary
build:
	@echo Building Zunit...

	# Ensure the bin directory exists
	@mkdir -p ${BIN}
	@mkdir -p ${OUT}
	
	# Add the header text to the binary
	@printf "${HEADER_TEXT}" > ${PROG}
	
	# Add the auto-generated warning banner
	@echo "${BANNER}" >> ${PROG}
	
	# Process each source file and append its contents to the program
	@for src in ${GLOB}; do \
		echo "----> Processing $$src"; \
		cat "$$src" | grep -v -e '#\svim.*' -e '^(\s*#.*|\s*)\$$' >> ${PROG}; \
	done

	# Replace placeholders with actual values
	@$(call ised,"s/{{ZUNIT_REVISION}}/$$(git log -n1 --format=%h -- src)/",${PROG})
	@$(call ised,"s/{{ZUNIT_REVISION_DATE}}/$$(git log -n1 --format='%ai' -- src)/",${PROG})
	@$(call ised,"s/{{ZUNIT_VERSION}}/$$(cat ${VERSION_FILE})/",${PROG})
	
	@install -cv -m755 ${PROG} ${EXEC}
	@rm -rf ${OUT}
